<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
    <h1>
        Searching and Marking
      </h1>
      
      <input type="text" id="search"/>
      <button onClick="search(id)" id="button">
      Highlight
      </button>
      
      <p id="text">
      What exactly is this Worker thread module, and why do we need it? In this post, we will talk about the historical reasons concurrency is implemented in JavaScript and Node.js, the problems we might find, current solutions, and the future of parallel processing with Worker threads.
      
      Living in a single-threaded world
      JavaScript was conceived as a single-threaded programming language that ran in a browser. Being single-threaded means that only one set of instructions is executed at any time in the same process (the browser, in this case, or just the current tab in modern browsers).
      
      This made things easier for implementation and for developers using the language. JavaScript was initially a language only useful for adding some interaction to webpages, form validations, and so on â€” nothing that required the complexity of multithreading.
      </p>
    <script>
        function search(e) {
	let searched = document.getElementById("search").value.trim();
  if (searched !== "") {
  	let text = document.getElementById("text").innerHTML;
  	let re = new RegExp(searched,"g"); // search for all instances
		let newText = text.replace(re, `<mark>${searched}</mark>`);
		document.getElementById("text").innerHTML = newText;
  }
}
    </script>
</body>
</html>